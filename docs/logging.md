Fabulous - Guide
=======

{% include_relative contents.md %}

Traces and crashes
------

In Fabulous, everything that happens in the app is centralized in a single message loop that is responsible for calling your `init`, `update` and `view` functions.  
Fabulous allows you to plug into this loop to run your custom logic such as logging and error handling.

There's a few built-in functions available already:
| Functions                 | Description |
| ------------------------- | ----------- |
| Program.withConsoleTrace  | Print every message, model and exceptions received and/or generated by the init, update and view functions. <br/>Really useful while debugging. Might slow down the app a bit. |
| Program.withTrace (trace) | Call your custom tracing function everytime Fabulous needs to update the app. (signature: `'msg -> 'model -> unit`) |
| Program.withErrorHandler (onError)  | Call your custom error handling logic. (signature: `string * exn -> unit` ) |

To use them, you will need to add them into your runner, before calling `runWithDynamicView`.
You can combine them, they will be called one after another from top to bottom of the order of declaration.
```fsharp
type App () as app = 
    inherit Application ()

    let runner = 
        Program.mkProgram App.init App.update App.view
        |> Program.withConsoleTrace
        |> Program.withErrorHandling (fun (message, exn) -> writeToDisk exn)
        |> Program.runWithDynamicView app
```
In this example, logs will be output to the console before the error handler can write the exceptions to the disk.

Writing your own trace function
------

Writing your own trace function is simple.  
You need to make a function that accepts a `Program<'model, 'msg, 'view>` and that outputs another `Program<'model, 'msg, 'view>`

This `Program` defines the handlers that are responsibles for calling `init`, `update` and `views` as well handle errors.
You can define your own handlers instead to do additional logic.  
**Make sure to call the previous `Program` handlers in your own, otherwise you will completely bypass what Fabulous tries to do**

Here's a simple example that prints a message each time something happens

```fsharp
let withSimpleTrace (program: Program<'model, 'msg, _>) =
    let traceInit () =
        Console.WriteLine "Init"
        program.init ()

    let traceUpdate msg model =
        Console.WriteLine "Update"
        program.update msg model

    let traceView model dispatch =
        Console.WriteLine "View"
        program.update msg model

    let traceOnError (message, exn) =
        Console.WriteLine "Error"
        program.onError (message, exn)
            
    { program with
        init = traceInit 
        update = traceUpdate
        view = traceView
        onError = traceOnError }


type App () as app = 
    inherit Application ()

    let runner = 
        Program.mkProgram App.init App.update App.view
        |> Program.withSimpleTrace
        |> Program.runWithDynamicView app
```

You're not required to implement all handlers, if you only need to override `update` then just override that one.

```fsharp
let withSimpleTrace (program: Program<'model, 'msg, _>) =
    let traceUpdate msg model =
        Console.WriteLine "Update"
        program.update msg model

    { program with update = traceUpdate }
```

AppCenter
------

Here's a good example of implementing our own trace function.

[Visual Studio App Center](https://appcenter.ms) is a DevOps portal tailored for mobile application development.  
It handles everything from build, tests, distribution, analytics and crashes reporting.

Those last two are what interest us here.  
We want to trace some actions in our app to be able to tell if our users use a set of functionalities, as well to be able to tell if users encounter crashes (if so what crashes).

AppCenter provides us with a really simple way to report analytics and crashes to it.  
We only need to install the following packages:
- [`Microsoft.AppCenter.Analytics`](https://www.nuget.org/packages/Microsoft.AppCenter.Analytics/)
- [`Microsoft.AppCenter.Crashes`](https://www.nuget.org/packages/Microsoft.AppCenter.Crashes/)

In our `App` class, we need to call `AppCenter.Start("appsecrets", typeof<Analytics>, typeof<Crashes>)` to initialize it.

```fsharp
module AppCenter =
    type AppCenterUpdateTracer<'msg, 'model> =
        'msg -> 'model -> (string * (string * string) list) option

    /// Initialize AppCenter Analytics and Crashes modules
    let start secrets =
        AppCenter.Start(secrets, typeof<Analytics>, typeof<Crashes>)

    /// Trace all the updates to AppCenter
    let withAppCenterTrace (shouldTraceUpdate: AppCenterUpdateTracer<_, _>) (program: Program<_, _, _>) =
        let traceUpdate msg model =
            match shouldTraceUpdate msg model with
            | Some (key, value) -> Analytics.TrackEvent (key, dict value)
            | None -> ()
            program.update msg model

        let traceError (message, exn) =
            Crashes.TrackError(exn, dict [ ("Message", message) ])

        { program with
            update = traceUpdate 
            onError = traceError }
```

Usage:
```fsharp
module Tracing =
    let hasValue = (not << String.IsNullOrEmpty) >> string

    let rules msg _ =
        match msg with
        | App.Msg.GoToAbout ->
            Some ("Navigation", [ ("Page", "About") ])
        | App.Msg.NavigationPopped ->
            Some ("Back Navigation", [])
        | App.Msg.UpdateWhenContactAdded c ->
            Some ("Contact added", [
                ("Has Email", hasValue c.Email)
                ("Has Phone", hasValue c.Phone)
                ("Has Address", hasValue c.Address)
            ])
        | _ -> None
```
```fsharp
type App () as app = 
    inherit Application ()

    do AppCenter.start "ios=(...);android=(...)"

    let runner = 
        Program.mkProgram App.init App.update App.view
        |> AppCenter.withAppCenterTrace Tracing.rules
        |> Program.runWithDynamicView app
```